# HW2 Template
Домашнее задания HW2.

Содержит 5 заданий.

Темы : ООП, Исключения, Коллекции.

Все задания уже имеют программный каркас.
Задача программиста - реализовать недостающие блоки функциональности.

## Структура исходного кода
Каталог с решением имеет следующую структуру :
- **editorconfig** - файл с правилами форматирования кода; запрещен к модификации;
- **Directory.Build.props** - файл с настройки решения; запрещен к модификации;
- **Hw2.Exercise1** - проект приложения “Валидатор последовательности скобок”;
    - **BracketsApplication.cs** - основной класс приложения; не требует доработок;
    - **BracketsValidator.cs** - класс-валидатор последовательности скобок, который должен быть доработан студентом в соответствии с заданием;
    - **Program.cs** - класс-точка входа в приложения; не требует доработок;
- **Hw2.Exercise2** - проект приложения “Обмен валют”;
    - **CurrencyRates.cs** - класс с логикой обмена валют, который должен быть доработан студентом в соответствии с заданием;
    - **CurrencyRatesApplication.cs** - основной класс приложения; не требует доработок;
    - **ExchangeRequest.cs** - структура для передачи параметров (*Data Transafer Object - DTO*) для обмена валют, который должен быть доработан студентом в соответствии с заданием;
    - **Program.cs** - класс точка входа в приложения; не требует доработок;
- **Hw2.Exercise3** - проект приложения “Расширяемое консольное приложение”;
    - **CliApplication.cs** - основной класс приложения, который должен быть доработан студентом в соответствии с заданием;
    - **Program.cs** - класс-точка входа в приложения; не требует доработок;
    - **Plugins** - директория с классами системы плагинов;
        - **EchoPlugin.cs** - класс-плагин, который реализует функцию "Эхо"; не требует доработок;
        - **ICliPlugin.cs** - базовый интерфес плагина консольного приложения; не требует доработок;
- **Hw2.Exercise4** - проект приложения “Сортировки”;
    - **Program.cs** - класс-точка входа в приложения; не требует доработок;
    - **SortApplication.cs** - основной класс приложения; не требует доработок;
    - **SortRequest.cs** - класс для передачи параметров (DTO) для сортировки, который должен быть доработан студентом в соответствии с заданием;
    - **Sorting** - директория с классами, которые реализует различные алгоритмы сортировки; директория должна быть наполнена алгоритмами сортировки в соответствии с заданием;
        - **SortBase** - класс, который представляет некий абстрактный алгоритм сортировки; не требует доработок;
        - **SortFactory** - класс фабрика, которая возвращает запрашиваемый алгоритм сортировки; класс должен быть доработан студентом в соответствии с заданием;
- **Hw2.Exercise5** - проект библиотеки “Система Биллинга (СБ)”;
    - **Models** - директория, которая содержит модели для взаимодействия с СБ; директория должна быть дополнена необходимыми моделями в соответствии с заданием;
        - **ITransactionRequest.cs** - интерфейс запроса на обработку транзакции СБ; не требует доработок;
        - **ITransactionResponse.cs** - интерфейс ответа на запрос на обработку транзакции СБ; не требует доработок;
        - **IUserBalancesResponse.cs** - интерфейс запроса балансов пользователя у СБ; не требует доработок;
        - **TransactionResult.cs** - перечесление статусов  ответа на запрос на обработку транзакции СБ; не требует доработок;
    - **Services** - директория, которая содержит интерфейс и реализацию СБ;
        - **BillingService.cs** - основной класс библиотеки (СБ), который должен быть доработан студентом в соответствии заданием;
        - **IBillingService.cs** - интерфейс СБ; не требует доработок.
- **Hw2.Tests** - тестовый проект для всех заданий; запрещен к модификации.

## Общее введение
Представьте ситуацию, что Вы первый день на новом рабочем месте... Вы получаете электронное письмо от коллеги-ментора, который срочно уехал на конференцию.

```
Привет дорогой друг! 
Мы еще не знакомы, но скоро познакомимся - корпоратив не за горами. А я да! 
Извини - пришлось срочно уехать. Тебе придется разбираться самому.
Я подготовил каркас для 5 проектов и тесты к ним (TDD). 

Можно сказать, что вся работа уже сделана - 
тебе осталось только немного доработать некоторые классы.

Тесты и требования от заказчика в помощь!
```

## Задание 1. Приложение “Валидатор последовательности скобок”
Разработать приложение “Валидатор последовательности скобок”.

### Введение
Консольное приложение “Валидатор последовательности скобок” позволяет пользователю проверить, что заданная (через аругменты командной строки) последовательность символов является правильной последовательностью скобок. 

Последовательность символов является правильной последовательностью скобок, если все символы-скобки открываются в правильном порядке.

Например : `(a+b)` - это правильная последовательность, а `(a+b(` - неправильная.

### Задание
Необходимо разработать приложение “Валидатор последовательности скобок”, которое отображает результат проверки последовательности символов на наличие скобок в правильном порядке.

**Требования** :
- Приложения принимает последовательность символов через аргументы командной строки;
- Приложение выводит результат проверки на консоль :
    - `True` - последовательность правильная или вообще не содержит скобок и/или других символов;
    - `False` - последовательность содержит скобки в неправильном порядке.
- Приложение возвращает такие статус-коды :
    - `0` - последовательность правильная или вообще не содержит скобок и/или других символов;
    - `-1` - ошибка обработки аргументов командной строки;
    - `-2` - последовательность содержит скобки в неправильном порядке.
- Приложения поддерживает такие **пары скобок** : `( )`, `[ ]`, `{ }`, `<>`; остальные символы игнорируются.
    
**Для выполнения задания, необходимо предоставить собственную реализацию следующих методов классов/стуктур:**
- Класс `BracketsValidator` :
    - Метод `bool IsSequenceValid(string sequence)` :
        - Возвращает результат проверки последовательности символов :
            - `True` - последовательность правильная или вообще не содержит скобок и/или других символов;
            - `False`- последовательность содержит скобки в неправильном порядке.
        - Бросает исключение `System.ArgumentNullException`, если аргумент `sequence` является `null` :
            - Исключение содержит имя параметра, который стал причиной исключения.
    - **Обязательным требованием** является использование стандартного класса `System.Collections.Generic.Stack<T>` и следовательно популярного алгоритма на базе стека.

**Пример использования приложения :**
```
C:\Users\test.user\demo.path>Hw2.Exercise1.exe (ab)
True
```

### Советы
- Алгоритм проверки последовательности скобок на базе стека основывается на идее, что открывающая скобка помещается в стек (метод `Stack<T>.Push(T)`), а закрывающая скобка, пытается забрать с вершины стека свою открывающую пару (метод `Stack<T>.TryPop(T)`).

### Чек-лист
- Реализован метод `IsSequenceValid` существующего класса `Hw2.Exercise1.BracketsValidator`;
- Решение проходит все тест-кейсы, которые содержит тестовый проект;
- Нет сообщения об ошибках касательно форматирования кода;
- Код реализации загружен в приватный репозиторий, а коммит отправлен в LMS.

## Задание 2. Приложение “Обмен валют”
Разработать приложение “Обмен валют”.

### Введение
Консольное приложение “Обмен валют” позволяет пользователю узнать, какую сумму он получит в результате обмена валют.

Пользователь задают сумму в исходной валюте, ISO-код исходной валюты и ISO-код желаемой валюты; на выходе пользователь получает сумму в желаемой валюте.

Например : `10 EUR USD` - означает запрос на конвертацию 10 Евро в доллар США; результат `10 EUR = 12 USD`.

### Задание
Необходимо разработать приложение “Обмен валют” , которое выводит результат потенциального обмена валют.

**Требования** :
- Приложения принимает параметры обмена валют через аргументы командной строки :
    - Формат запроса `Amount SourceCurrency DestCurrency`, где :
        - `Amount` - сумма к обмену типа decimal, 
        - `SourceCurrency` - валюта исходной суммы,
        - `DestCurrency` - желаемае валюта.
- В случае успешного обмена валют, приложение выводит результат конвертации на консоль в формате `"{0:G4} {1} = {2:G4} {3}"` где :
    - `0` - исходная сумма,
    - `1` - исходная валюта,
    - `2` - сумма после конвертации,
    - `3` - желаемая валюта,
    - `G4` - стандарный формат General-4.
- Приложение возвращает такие статус-коды :
    - `0` - успешный обмен валют;
    - `-1` - ошибка обработки аргументов командной строки;
    - `-2` - неизвестная валюта (исходная и/или желаемая).
- По умолчанию приложение поддерживает такие коды валют: `EUR`, `USD`.

**Для выполнения задания, необходимо предоставить собственную реализацию следующих методов классов/стуктур:**
- Класс `CurrencyRates` :
    - Конструктор `CurrencyRates(IDictionary<string, decimal> rates)`
        - Принимает словарь `rates`, где Ключ - код валюты, а Значение - курс, относительно некой базовой валюты (например EUR);
        - Бросает исключение `System.ArgumentNullException`, если аргумент `rates` является `null` :
            - Исключение содержит имя параметра, который стал причиной исключения.
        - Бросает исключение `System.ArgumentException`, если значения словаря `rates` содержит:
            - курс валюты равное или меньше нуля;
            - несколько кодов одной валюты в разных регистрах (например : `USD` и `usd`).
            - Исключение содержит имя параметра, который стал причиной исключения.
    - Метод `decimal? Exchange(ExchangeRequest request)` :
        - Возвращает результат обмена валют :
            - число - в случае успешного обмена валют;
            - `null` - если задана неизвестная валюта.            
        - Бросает исключение `System.ArgumentException`, если аргумент `request` не проходит валидацию (на основе свойства `ExchangeRequest.IsValid`) :
            - Исключение содержит имя параметра, который стал причиной исключения.
        - Не чувствителен к регистру валют в запросе `request` (например, и `EUR` и `eur` должно трактоваться как Евро).
- Класс `ExchangeRequest` :
    - Метод `bool TryParse(string[] args, out ExchangeRequest request)` :
        - Пытается создать `ExchangeRequest` на основании аргументов командной строки `args`;
        -  Возвращает результат попытки создать `ExchangeRequest`:
            - `true` - успех;
            - `false`- неудалось разобрать аргументы командной строки.
        - Возвращает созданный `ExchangeRequest` через out параметр `request`, в случае успешной обработки аргументов командной строки.


**Пример использования приложения :**
```
C:\Users\test.user\demo.path>Hw2.Exercise2.exe 10 EUR USD
10 EUR = 12 USD
```

### Советы
- Чтобы делать приведение строки к числу c плавающей запятой, независимо от текущей культуры - замените запятые на точки, а потом используйте инвариантную культуру для приведения :
``` cpp
// using System.Globalization;
str = str.Replace(',', '.');
return Decimal.TryParse(str, NumberStyles.Number, CultureInfo.InvariantCulture, out var value);
```

### Чек-лист
- Реализованы конструктор и метод `Exchange` существующего класса `Hw2.Exercise2.CurrencyRates`;
- Реализован метод `TryParse` существующего класса `Hw2.Exercise2.ExchangeRequest`;
- Решение проходит все тест-кейсы, которые содержит тестовый проект;
- Нет сообщения об ошибках касательно форматирования кода;
- Код реализации загружен в приватный репозиторий, а коммит отправлен в LMS.

## Задание 3. Расширяемое консольное приложение
Разработать расширяемое консольное приложение.

### Введение

Расширяемое консольное приложение - это приложение, которое играет роль хоста для набора плагинов.
Плагины обрабатывают аргументы командной строки согласно своей внутренней логике.
По умолчанию приложение содержит один плагин - "Эхо". Этот плагин выводит авргументы командной строки на консоль.

Так как работа плагинов непредсказуема для приложения, то приложение должно перехватывать потенциальные ошибки, которые могут произойти при работе плагинов.
Плагины должны реализовывать базовый интерфейс плагина.
Список плагинов передается в приложение на этапе инциализации.

### Задание
Необходимо разработать консольное приложение, которое можно расширять с помощью плагинов.

**Требования** :
- Приложения принимает аргументы командной строки и передает их плагинам;
- Если ни один плагин не "взялся" за обработку аргументов, то приложение возвращает соответствующий код ошибки `-1`;
- Если во время работы плагинов произошла непредвиденная ошибка, то приложение возвращает соответствующий код ошибки `-2`;
- Приложение возвращает такие статус-коды :
    - `0` - аргументы командной строки обработаны успешно;
    - `-1` - ни один плагин не взял аргументы в работу;
    - `-2` - непредвиденная ошибка в системе плагинов.
- Плагины реализуют интерфейс `ICliPlugin` :
    - Интерфейс `ICliPlugin` содержит единственный метод `bool Handle(string[] args)` :
        - Метод возвращает :
            - `true`, если плагин готов принять аргументы командной строки `args` (например, если первый аргумент `echo` - то стандарнтый плагин EchoPlugin должен взять аргументы в работу);
            - `false`, если плагин не готов принять аргументы командной строки `args`.
- Приложение опрашивает плагины последовательно (вызывая метод `bool ICliPlugin.Handle(string[] args)`), согласно порядку при регистрации плагинов на этапе иницализации приложения.

**Для выполнения задания, необходимо предоставить собственную реализацию следующих методов классов/стуктур:**
- Класс `CliApplication` :
    - Конструктор `CliApplication(IEnumerable<ICliPlugin> plugins)`
        - Принимает перечисление `plugins`, которая содержит список плагинов в необходимом порядке;
        - Бросает исключение `System.ArgumentNullException`, если аргумент `plugins` является `null` :
            - Исключение содержит имя параметра, который стал причиной исключения.
        - Бросает исключение `System.ArgumentException`, если перечисление `plugins` содержит `null`:
            - Исключение содержит имя параметра, который стал причиной исключения.
    - Метод `ReturnCode Run(string[] args)` :
        - Последовательно проходит по зарегистрированным (через конструктор класса `CliApplication`) плагинам и вызывает метод `bool ICliPlugin.Handle(string[] args)`, где `args` - это аргументы командной строки;
        - Возвращает результат работы системы плагинов :
            - `ReturnCode.Success` - аргументы командной строки обработаны успешно; 
            - `ReturnCode.PluginNotFound` - ни один плагин не взял аргументы в работу;
            - `ReturnCode.PluginError` - непредвиденная ошибка в системе плагинов - один из плагинов во время работы бросил исключение.
        - Перехватыват потенциальные исключения, которые могут бросать плагины и возврщает результат `ReturnCode.PluginError`;

**Пример использования приложения :**
```
C:\Users\test.user\demo.path>Hw2.Exercise3.exe echo test
test
```

### Советы
- Чтобы перехватить исключение плагина - используйте блок `try-catch`.

### Чек-лист
- Реализованы конструктор и метод `Run` существующего класса `Hw2.Exercise3.CliApplication`;
- Решение проходит все тест-кейсы, которые содержит тестовый проект;
- Нет сообщения об ошибках касательно форматирования кода;
- Код реализации загружен в приватный репозиторий, а коммит отправлен в LMS.

## Задание 4. Приложение “Сортировки”
Разработать приложение “Сортировки”.

### Введение
Консольное приложение “Сортировки” позволяет пользователю задать алгоритм сортировки и список целых чисел для сортироки.
Пользователь задает параметры программы через аргументы командной строки.
Приложение должно поддерживать минимум три алгоритма сортировки : 
- Bubble (bubble sort) - сортировка перестановкой или "пузырьком";
- System - сортировка средствами фреймворка .Net;
- Quick (quick sort) - сортировка quicksort.
Приложение должно отобразить отсортированный массив и длительность сортировки.

### Задание
Необходимо разработать приложение “Сортировки”, которое отображает результат сортировки массива целых чисел и время выполнения сортировки.

**Требования** :
- Приложения принимает параметры сортировки через аргументы командной строки :
    - Формат запроса `SortAlgorithmName int0 int1 ... intn`, где :
        - `SortAlgorithmName` - один из алгоритмов из минимального набора :
            - `Bubble` - сортировка перестановкой или "пузырьком";
            - `System` - сортировка средствами фреймворка .Net;
            - `Quick` - сортировка quicksort.
        - `int0 int1 ... intn` - целые числа, разделенные пробелами.
- В случае успешной сортировки, приложение выводит результаты сортировки на консоль в формате `int0;int1; ... intn;` и время выполнения сортировки в формате `"At '{0}'"`  где :
    - `int0;int1; ... intn;` - целые числа, разделенные `;`.
    - `{0}` - время выполнения сортировки.
- Приложение возвращает такие статус-коды :
    - `0` - успешная сортировка;
    - `-1` - ошибка обработки аргументов командной строки;
    - `-2` - неизвестный алгоритм сортироки.

**Для выполнения задания, необходимо предоставить собственную реализацию следующих методов классов/стуктур:**
- Класс `SortRequest` :
    - Метод `bool TryParse(string[] args, out SortRequest request)` :
        - Пытается создать `SortRequest` на основании аргументов командной строки `args`;
        -  Возвращает результат попытки создать `SortRequest`:
            - `true` - успех;
            - `false`- неудалось разобрать аргументы командной строки.
        - Возвращает созданный `SortRequest` через out параметр `request`, в случае успешной обработки аргументов командной строки.
- Класс `SortFactory` :
    - Метод `SortBase ResolveSort(string algorithm)`
        - Принимает название алгоритма сортировки `algorithm`;
        - На основе имени алгоритма, создает соответствующий класс-наследник абстрактного класса SortBase;
        - Если запрошен неизвестный алгоритм, то метод возвращает `null`.
        - **Невосприимчив к регистру** параметра `algorithm` (т.е. и `Quick` и `quick` - валидные значения).
- Класс `BubbleSort` - наследник класса SortBase (должен быть добавлен в директорию `Sorting`)
    - Метод `void Sort(int[] array)` :
        - Сортирует массив `array` по алгоритму bubble sort (сортировка "пузырьком" или перестановкой);
        - Бросает исключение `System.ArgumentNullException`, если аргумент `array` является `null` :
            - Исключение содержит имя параметра, который стал причиной исключения.
- Класс `SystemSort` - наследник класса SortBase (должен быть добавлен в директорию `Sorting`)
    - Метод `void Sort(int[] array)` :
        - Сортирует массив `array` средствами фрейморка .Net - допускается любое стандартное решение платформы;
        - Бросает исключение `System.ArgumentNullException`, если аргумент `array` является `null` :
            - Исключение содержит имя параметра, который стал причиной исключения.
- Класс `QuickSort` - наследник класса SortBase (должен быть добавлен в директорию `Sorting`)
    - Метод `void Sort(int[] array)` :
        - Сортирует массив `array` по алгоритму quicksort;
        - Бросает исключение `System.ArgumentNullException`, если аргумент `array` является `null` :
            - Исключение содержит имя параметра, который стал причиной исключения.

Пример использования приложения :
```
C:\Users\test.user\demo.path>Hw2.Exercise4.exe system 1 9 2 8 3 7 4 6 5
1;2;3;4;5;6;7;8;9;
At '00:00:00.0000931'
```

### Советы
- Для реализации алгоритма сортировки `System` можно использовать метод `Sort<T>(T[] array)` класса `System.Array`.

### Чек-лист
- Реализован метод `ResolveSort` существующего класса `Hw2.Exercise4.SortFactory`;
- Реализован метод `TryParse` существующего класса `Hw2.Exercise4.SortRequest`;
- Создан класс `BubbleSort` (`Sorting\BubbleSort.cs`);
- Создан класс `SystemSort` (`Sorting\SystemSort.cs`);
- Создан класс `QuickSort` (`Sorting\QuickSort.cs`);
- Решение проходит все тест-кейсы, которые содержит тестовый проект;
- Нет сообщения об ошибках касательно форматирования кода;
- Код реализации загружен в приватный репозиторий, а коммит отправлен в LMS.


## Задание 5. Библиотека “Система биллинга”
Разработать библиотеку “Система биллинга” (или просто "СБ").

### Введение
Система билинга позволяет хранить средства на счетах пользователя и переводить эти средства со счета на счет.

### Задание
Необходимо библиотеку “СБ”, которая позволяет хранить средства на счетах пользователя и переводить эти средства со счета на счет.

**Описание моделей и сервисов библиотеки**

- Интерфейс `IBillingService` описывает следующие методы :
    - метод `IUserBalancesResponse GetUserBalances(string userId)` :
        - Принимает параметр `userId` - идентификатор пользователя;
        - Возвращает остатки по счетам во всех валютах пользователя;
        - Возвращает `null`, если пользователь не был найдет (не было движений по счету).
    - метод `ITransactionResponse ProcessTransaction(ITransactionRequest request)` :
        - Принимает параметр `request` - DTO с деталями транзакции на обработку системой биллинга;
        - Возвращает результат обработки запроса `request`;
        - Обрабатывает запрос, даже если `request` = `null`;
        - Создает пользователя, если это первое движение по счету пользователя;
        - Создает валюты и счета, если это первое движение по валюте и/или счету.
- Интерфейс `ITransactionRequest` описывает DTO с деталями транзакции на обработку системой биллинга и содержит следующие поля :
    - `TransactionId` - уникальный идентификатор транзакции;
    - `Amount` - сумма транзакции в валюте `Currency`;
    - `Currency` - валюта транзакции;
    - `SourceUserId` - пользователь с которого списываются средства в размере `Amount`;
    - `DestUserId` - пользователь которому начисляются средства в размере `Amount` (может совпадать с `SourceUserId`);
    - `SourceBalance` - название баланса с которого списываются средства в размере `Amount` у пользователя `SourceUserId`;
    - `DestBalance` - название баланса на который начисляются средства в размере `Amount` пользователю `DestUserId`;
    - `OverdraftAllowed` - флаг, который разрешает проводить транзакцию, даже если в результате операции `SourceBalance` станет меньше нуля;
    - `Timestamp` - время создании транзакции;
    - `Metadata` - произвольные данные о транзакции.
- Интерфейс `ITransactionResponse` описывает DTO с деталями транзакции на обработку системой биллинга и содержит следующие поля :
    - `Result` - результат обработки транзакции; может принимать значения :
        - `Success` - транзакция обработана успешно;
        - `Fail`  - транзакция необработана (или статус неизвестен) из-за неожиданной ошибки;
        - `InsufficientFunds` - недостаточно средств на балансе пользователя (если провести операцию, то `ITransactionRequest.SourceBalance` станет меньше нуля, а `ITransactionRequest.OverdraftAllowed` имеет значение `false`);
        - `InvalidRequest` - запрос не проходит валидацию если:
            - запрос не пердан (`null`);
            - не заполнено одно из обязательных полей `ITransactionRequest` (все поля обязательные, кроме поля `Metadata`);
            - попытка перевести средства на исходный счет (для одно пользователя);
            - сумма меньше или равна нулю.
    - `Currency` - валюта транзакции;
    - `SourceBalances` - балансы отправителя платежа в валюте `Currency`;
    - `DestBalances` - балансы получателя платежа в валюте `Currency`.
- Интерфейс `IUserBalancesResponse` описывает DTO с балансами пользователя и содержит следующие поля :
    - `Balances` - балансы пользователя, которые описываются структурой `Валюта-Счет-Остаток`.

**Для выполнения задания, необходимо предоставить собственную реализацию следующих методов классов/интерфейсов:**
- Класс `BillingService` :
    - Метод `IUserBalancesResponse GetUserBalances(string userId)` согласно требованиям интерфейса `IBillingService`.
    - Метод `ITransactionResponse ProcessTransaction(ITransactionRequest request)` согласно требованиям интерфейса `IBillingService`.
- Класс `TransactionRequest` :
    - Все свойства согласно требованиям интерфейса `ITransactionRequest`.
- Класс `TransactionResponse` :
    - Все свойства согласно требованиям интерфейса `ITransactionResponse`.
- Класс `UserBalancesResponse` :
    - Все свойства согласно требованиям интерфейса `IUserBalancesResponse`.    

### Советы
- Для храения данных о пользователях(их валютах и счетах) можно использовать приватную статическую переменную в экземпляре `BillingService`; например такого типа `Dictionary<string, Dictionary<string, Dictionary<string, decimal>>>` - первый словарь хранит игроков, второй - их валюты, а третий - счета.

### Чек-лист
- Реализован метод `GetUserBalances` существующего класса `Hw2.Exercise5.BillingService`;
- Реализован метод `ProcessTransaction` существующего класса `Hw2.Exercise5.BillingService`;
- Создан класс `TransactionRequest` (`Models\TransactionRequest.cs`);
- Создан класс `TransactionResponse` (`Models\TransactionResponse.cs`);
- Создан класс `UserBalancesResponse` (`Models\UserBalancesResponse.cs`);
- Решение проходит все тест-кейсы, которые содержит тестовый проект;
- Нет сообщения об ошибках касательно форматирования кода;
- Код реализации загружен в приватный репозиторий, а коммит отправлен в LMS.
